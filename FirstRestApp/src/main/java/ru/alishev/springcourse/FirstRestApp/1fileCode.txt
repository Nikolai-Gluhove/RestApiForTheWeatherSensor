===== FILE: ./models/Measurement.java =====

package ru.alishev.springcourse.FirstRestApp.models;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import org.hibernate.validator.constraints.Range;

import java.time.LocalDateTime;

@Entity
@Table(name = "measurement")
public class Measurement {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private int id;

    @Column(name = "value")
    @Range(min = -100, max = 100, message = "Значение должно быть от -100 до 100")
    @NotNull(message = "значение не может быть пустым")
    private Double value;

    @Column(name = "raining")
    @NotNull(message = "значение не может быть пустым")
    private Boolean raining;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sensor_id", nullable = true)
    private Sensor sensor;

    @Column(name = "data_time")
    @NotNull
    private LocalDateTime dateTime;

    public Measurement() {
    }

    public Measurement(Double value, Boolean raining, Sensor sensor, LocalDateTime dateTime) {
        this.value = value;
        this.raining = raining;
        this.sensor = sensor;
        this.dateTime = dateTime;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Double getValue() {
        return value;
    }

    public void setValue(Double value) {
        this.value = value;
    }

    public Boolean isRaining() {
        return raining;
    }

    public void setRaining(Boolean raining) {
        this.raining = raining;
    }

    public Sensor getSensor() {
        return sensor;
    }

    public void setSensor(Sensor sensor) {
        this.sensor = sensor;
    }

    public LocalDateTime getDateTime() {
        return dateTime;
    }

    public void setDateTime(LocalDateTime dateTime) {
        this.dateTime = dateTime;
    }
}


===== FILE: ./models/Sensor.java =====

package ru.alishev.springcourse.FirstRestApp.models;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;

@Entity
@Table(name = "sensor")
public class Sensor {
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Column(name = "name")
    @NotEmpty(message = "Name should not be empty")
    @Size(min = 3, max = 30, message = "Name should be between 3 and 30 characters")
    private String name;

    public Sensor() {
    }

    public Sensor(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


===== FILE: ./services/SensorService.java =====

package ru.alishev.springcourse.FirstRestApp.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import ru.alishev.springcourse.FirstRestApp.models.Sensor;
import ru.alishev.springcourse.FirstRestApp.repositories.SensorRepository;

import java.util.Optional;

@Service
@Transactional(readOnly = true)
public class SensorService {

    private final SensorRepository sensorRepository;

    @Autowired
    public SensorService(SensorRepository sensorRepository) {
        this.sensorRepository = sensorRepository;
    }

    public Optional<Sensor> findByName(String name){
        return sensorRepository.findByName(name);
    }

    @Transactional
    public void save(Sensor sensor){
        sensorRepository.save(sensor);
    }


}


===== FILE: ./services/MeasurementService.java =====

package ru.alishev.springcourse.FirstRestApp.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import ru.alishev.springcourse.FirstRestApp.error.MeasurementValidException;
import ru.alishev.springcourse.FirstRestApp.models.Measurement;
import ru.alishev.springcourse.FirstRestApp.models.Sensor;
import ru.alishev.springcourse.FirstRestApp.repositories.MeasurementRepository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Transactional(readOnly = true)
public class MeasurementService {

    private final MeasurementRepository measurementRepository;
    private final SensorService sensorService;

    @Autowired
    public MeasurementService(MeasurementRepository measurementRepository, SensorService sensorService) {
        this.measurementRepository = measurementRepository;
        this.sensorService = sensorService;
    }

    @Transactional
    public void save(Measurement measurement){
        Optional<Sensor> sensor = sensorService.findByName(measurement.getSensor().getName());
        if (!sensor.isPresent()){
            throw new MeasurementValidException("Сенсора с именем "+measurement.getSensor().getName()+" нет в системе");
        }
        measurement.setSensor(sensor.get());
        measurement.setDateTime(LocalDateTime.now());
        measurementRepository.save(measurement);
    }

    public List<Measurement> findAll(){
        return measurementRepository.findAll();
    }

    public long countByRainingTrue(){
        return measurementRepository.countByRainingTrue();
    }
}


===== FILE: ./repositories/SensorRepository.java =====

package ru.alishev.springcourse.FirstRestApp.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ru.alishev.springcourse.FirstRestApp.models.Sensor;

import java.util.Optional;

@Repository
public interface SensorRepository extends JpaRepository<Sensor, Integer> {

    Optional<Sensor> findByName(String name);
}


===== FILE: ./repositories/MeasurementRepository.java =====

package ru.alishev.springcourse.FirstRestApp.repositories;

import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ru.alishev.springcourse.FirstRestApp.models.Measurement;

import java.util.List;

@Repository
public interface MeasurementRepository extends JpaRepository<Measurement, Integer> {
    long countByRainingTrue();

    @Override
    @EntityGraph(attributePaths = {"sensor"})
    List<Measurement> findAll();
}


===== FILE: ./controllers/MeasurementController.java =====

package ru.alishev.springcourse.FirstRestApp.controllers;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.*;
import ru.alishev.springcourse.FirstRestApp.dto.MeasurementDTO;
import ru.alishev.springcourse.FirstRestApp.error.ErrorResponse;
import ru.alishev.springcourse.FirstRestApp.error.MeasurementValidException;
import ru.alishev.springcourse.FirstRestApp.models.Measurement;
import ru.alishev.springcourse.FirstRestApp.services.MeasurementService;
import ru.alishev.springcourse.FirstRestApp.util.Convector;
import ru.alishev.springcourse.FirstRestApp.util.MeasurementValidator;

import java.util.List;

@RestController
@RequestMapping("/measurements")
public class MeasurementController {

    private final MeasurementService measurementService;
    private final Convector convector;
    private final MeasurementValidator measurementValidator;

    @Autowired
    public MeasurementController(MeasurementService measurementService, Convector convector, MeasurementValidator measurementValidator) {
        this.measurementService = measurementService;
        this.convector = convector;
        this.measurementValidator = measurementValidator;
    }

    //добавление изменения
    @PostMapping("/add")
    public ResponseEntity<HttpStatus> add(@RequestBody @Valid MeasurementDTO measurementDTO,
                                          BindingResult bindingResult){

        measurementValidator.validate(measurementDTO, bindingResult);
        if (bindingResult.hasErrors()){
            StringBuilder errorMsg = new StringBuilder();

            List<FieldError> errors = bindingResult.getFieldErrors();
            for (FieldError error : errors){
                errorMsg.append(error.getField())
                        .append(" - ")
                        .append(error.getDefaultMessage())
                        .append("; ");
            }

            throw new MeasurementValidException(errorMsg.toString());
        }

        //нужна кастомна конвертация
        measurementService.save(convector.convectMeasurementAndMeasurementDTO(measurementDTO));
        return ResponseEntity.ok(HttpStatus.OK);
    }

    @ExceptionHandler
    private ResponseEntity<ErrorResponse> handleException(MeasurementValidException e){
        ErrorResponse response = new ErrorResponse(e.getMessage(), System.currentTimeMillis());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    //получить все изменения
    @GetMapping
    public List<Measurement> getAllMeasurements(){
        return measurementService.findAll();
    }

    //получить количество дождливых дней
    @GetMapping("/rainyDaysCount")
    public long getNumberOfRainyDays(){
        return measurementService.countByRainingTrue();
    }
}


===== FILE: ./controllers/SensorController.java =====

package ru.alishev.springcourse.FirstRestApp.controllers;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.*;
import ru.alishev.springcourse.FirstRestApp.dto.SensorDTO;
import ru.alishev.springcourse.FirstRestApp.error.ErrorResponse;
import ru.alishev.springcourse.FirstRestApp.error.SensorValidetException;
import ru.alishev.springcourse.FirstRestApp.services.SensorService;
import ru.alishev.springcourse.FirstRestApp.util.Convector;
import ru.alishev.springcourse.FirstRestApp.util.SensorValidator;

import java.util.List;

@RestController
@RequestMapping("/sensors")
public class SensorController {

    private final SensorService sensorService;
    private final Convector convector;
    private final SensorValidator sensorValidator;

    @Autowired
    public SensorController(SensorService sensorService, Convector convector, SensorValidator sensorValidator) {
        this.sensorService = sensorService;
        this.convector = convector;
        this.sensorValidator = sensorValidator;
    }

    //Регистрация сенсора
    @PostMapping("/registration")
    public ResponseEntity<HttpStatus> registration(@RequestBody @Valid SensorDTO sensorDTO,
                                                   BindingResult bindingResult){
        sensorValidator.validate(sensorDTO, bindingResult);
        if (bindingResult.hasErrors()){
            StringBuilder errorMsg = new StringBuilder();

            List<FieldError> errors = bindingResult.getFieldErrors();
            for (FieldError error : errors){
                errorMsg.append(error.getField())
                        .append(" - ")
                        .append(error.getDefaultMessage())
                        .append("; ");
            }

            throw new SensorValidetException(errorMsg.toString());
        }

        sensorService.save(convector.convectSensorAndSensorDTO(sensorDTO));
        return ResponseEntity.ok(HttpStatus.OK);
    }

    //ошибка валидации
    @ExceptionHandler
    private ResponseEntity<ErrorResponse> handleException(SensorValidetException e){
        ErrorResponse response = new ErrorResponse(e.getMessage(), System.currentTimeMillis());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
}


===== FILE: ./dto/SensorDTO.java =====

package ru.alishev.springcourse.FirstRestApp.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;

public class SensorDTO {
    @NotEmpty(message = "Name should not be empty")
    @Size(min = 3, max = 30, message = "Name should be between 3 and 30 characters")
    private String name;

    public SensorDTO() {
    }

    public SensorDTO(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


===== FILE: ./dto/MeasurementDTO.java =====

package ru.alishev.springcourse.FirstRestApp.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.hibernate.validator.constraints.Range;

public class MeasurementDTO {

    @Range(min = -100, max = 100, message = "Значение должно быть от -100 до 100")
    @NotNull(message = "значение не может быть пустым")
    private Double value;

    @NotNull(message = "значение не может быть пустым")
    private Boolean raining;

    @Valid
    private SensorDTO sensor;

    public MeasurementDTO() {
    }

    public MeasurementDTO(Double value, Boolean raining, SensorDTO sensor) {
        this.value = value;
        this.raining = raining;
        this.sensor = sensor;
    }

    public Double getValue() {
        return value;
    }

    public void setValue(Double value) {
        this.value = value;
    }

    public Boolean isRaining() {
        return raining;
    }

    public void setRaining(Boolean raining) {
        this.raining = raining;
    }

    public SensorDTO getSensor() {
        return sensor;
    }

    public void setSensor(SensorDTO sensor) {
        this.sensor = sensor;
    }
}


===== FILE: ./error/SensorValidetException.java =====

package ru.alishev.springcourse.FirstRestApp.error;

public class SensorValidetException extends RuntimeException {
    public SensorValidetException(String message) {
        super(message);
    }
}


===== FILE: ./error/MeasurementValidException.java =====

package ru.alishev.springcourse.FirstRestApp.error;

public class MeasurementValidException extends RuntimeException{
    public MeasurementValidException(String message) {
        super(message);
    }
}


===== FILE: ./error/ErrorResponse.java =====

package ru.alishev.springcourse.FirstRestApp.error;

public class ErrorResponse {
    private String message;
    private long timestamp;

    public ErrorResponse(String message, long timestamp) {
        this.message = message;
        this.timestamp = timestamp;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
}


===== FILE: ./FirstRestAppApplication.java =====

package ru.alishev.springcourse.FirstRestApp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FirstRestAppApplication {

	public static void main(String[] args) {
		SpringApplication.run(FirstRestAppApplication.class, args);
	}

}


===== FILE: ./util/MeasurementValidator.java =====

package ru.alishev.springcourse.FirstRestApp.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;
import ru.alishev.springcourse.FirstRestApp.dto.MeasurementDTO;
import ru.alishev.springcourse.FirstRestApp.services.SensorService;

@Component
public class MeasurementValidator implements Validator {
    private final SensorService sensorService;

    @Autowired
    public MeasurementValidator(SensorService sensorService) {
        this.sensorService = sensorService;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return MeasurementDTO.class.equals(clazz);
    }

    @Override
    public void validate(Object target, Errors errors) {
        MeasurementDTO measurementDTO = (MeasurementDTO)  target;

        if (!sensorService.findByName(measurementDTO.getSensor().getName()).isPresent()){
            errors.rejectValue("sensor.name", "400", "Сенсора "+measurementDTO.getSensor().getName()+" нет в системе");
        }
    }
}


===== FILE: ./util/AppConfig.java =====

package ru.alishev.springcourse.FirstRestApp.util;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public ModelMapper modelMapper(){
        return new ModelMapper();
    }
}


===== FILE: ./util/SensorValidator.java =====

package ru.alishev.springcourse.FirstRestApp.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;
import ru.alishev.springcourse.FirstRestApp.dto.SensorDTO;
import ru.alishev.springcourse.FirstRestApp.services.SensorService;

@Component
public class SensorValidator implements Validator {

    private final SensorService sensorService;

    @Autowired
    public SensorValidator(SensorService sensorService) {
        this.sensorService = sensorService;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return SensorDTO.class.equals(clazz);
    }

    @Override
    public void validate(Object target, Errors errors) {
        SensorDTO sensorDTO = (SensorDTO) target;

        if (sensorService.findByName(sensorDTO.getName()).isPresent()){
            errors.rejectValue("name", "400", "Имя "+sensorDTO.getName()+" занято");
        }
    }
}


===== FILE: ./util/Convector.java =====

package ru.alishev.springcourse.FirstRestApp.util;

import jakarta.validation.Valid;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import ru.alishev.springcourse.FirstRestApp.dto.MeasurementDTO;
import ru.alishev.springcourse.FirstRestApp.dto.SensorDTO;
import ru.alishev.springcourse.FirstRestApp.models.Measurement;
import ru.alishev.springcourse.FirstRestApp.models.Sensor;

@Configuration
public class Convector {
    private final ModelMapper modelMapper;

    @Autowired
    public Convector(ModelMapper modelMapper) {
        this.modelMapper = modelMapper;
    }

    public Sensor convectSensorAndSensorDTO(@Valid SensorDTO sensorDTO){
        return modelMapper.map(sensorDTO, Sensor.class);
    }

    public SensorDTO convectSensorAndSensorDTO(@Valid Sensor sensor){
        return modelMapper.map(sensor, SensorDTO.class);
    }

    public Measurement convectMeasurementAndMeasurementDTO(@Valid MeasurementDTO measurementDTO) {
        return modelMapper.map(measurementDTO, Measurement.class);
    }

    public MeasurementDTO convectMeasurementAndMeasurementDTO(@Valid Measurement measurement){
        return modelMapper.map(measurement, MeasurementDTO.class);
    }
}
